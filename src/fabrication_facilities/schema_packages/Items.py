#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# import datetime
from typing import (
    TYPE_CHECKING,
)

import numpy as np
from nomad.datamodel.data import (
    ArchiveSection,
    EntryData,
)
from nomad.datamodel.metainfo.basesections import (
    Entity,
)
from nomad.metainfo import (
    MEnum,
    Package,
    Quantity,
    Section,
    SubSection,
)

import plotly.graph_objects as go

from nomad.datamodel.metainfo.plot import PlotSection, PlotlyFigure

import plotly.graph_objs as go

if TYPE_CHECKING:
    pass

m_package = Package(name='Items plugin')


# In questa parte del plugin non mi piace come si inseriscono le propriet√† degli items
# forse sarebbe il caso di definirle una per una


class ItemPropertyDefinition(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                    'unit',
                    'value',
                ]
            }
        },
    )
    id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )
    unit = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    value = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity'},
    )


class StringProperties(ItemPropertyDefinition):
    m_def = Section(
        a_eln={
            'hide': ['unit'],
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                    'value',
                ]
            },
        },
    )
    value = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )


class NumericProperties(ItemPropertyDefinition):
    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                    'unit',
                    'value',
                ]
            }
        },
    )
    id = Quantity(
        type=int,
        a_eln={'component': 'NumberEditQuantity'},
    )
    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )
    unit = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    value = Quantity(
        type=np.float64,
        a_eln={'component': 'NumberEditQuantity'},
    )


class DopingProperties(ItemPropertyDefinition):
    m_def = Section(
        a_eln={'hide': ['unit']},
    )
    id = Quantity(
        type=int,
        a_eln={'component': 'NumberEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'RichTextEditQuantity'},
    )
    doping_type = Quantity(
        type=MEnum(
            [
                'p',
                'n',
                'no',
            ]
        ),
        a_eln={'component': 'EnumEditQuantity'},
    )


#    value = Quantity(
#        type=np.float64,
#        a_eln={
#            'component': 'NumberEditQuantity',
#            'defaultDisplayUnit': 'ppm',
#        },
#        unit='ppm',
#    )


class ItemShapeType(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                ]
            }
        },
    )

    id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )


class ListOfItemPropertyDefinition(EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'properties': {
                'order': [
                    'name',
                    'description',
                    'id',
                ]
            }
        },
    )

    name = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    list_of_possible_properties = SubSection(
        section_def=ItemPropertyDefinition,
        repeats=True,
    )
    list_of_items_shape_type = SubSection(
        section_def=ItemShapeType,
        repeats=True,
    )

class Contour(ArchiveSection):

    m_def=Section(
        description="""
        Ideal class to desceibe geometric shape used as base for other definitions
        """
    )

class Square(Contour):

    m_def=Section(
        description="""
        Ideal class usable to describe square shapes of items or objects of fabrication
        """
    )

    side=Quantity(
        type=np.float64,
        a_eln={
            'component':'NumberEditQuantity',
            'defaultDisplayUnit': 'cm'
        },
        unit='cm'
    )

class Circle(Contour):

    m_def=Section(
        description="""
        Ideal class usable to describe circular shapes of items or objects of fabrication
        """
    )

    radius=Quantity(
        type=np.float64,
        a_eln={
            'component':'NumberEditQuantity',
            'defaultDisplayUnit': 'cm'
        },
        unit='cm'
    )

class Rectangle(Contour):

    m_def=Section(
        description="""
        Ideal class usable to describe rectangle shapes of items or objects in fabrication
        """
    )

    base = Quantity(
        type=np.float64,
        a_eln={
            'component':'NumberEditQuantity',
            'defaultDisplayUnit': 'cm'
        },
        unit='cm'
    )

    height = Quantity(
        type=np.float64,
        a_eln={
            'component':'NumberEditQuantity',
            'defaultDisplayUnit': 'cm'
        },
        unit='cm'
    )

def make_geometric_represent(chuck,x,y,finalist):
    # Posizioni dei centri dei quadrati (in cm)
    #(x, y) devono stare dentro il cerchio di raggio 5
    posizione_centro = [(x, y)]
    # Chuck creation
    fig = go.Figure()
    if chuck is not None:
        if isinstance(chuck, Circle):
            theta = np.linspace(0, 2*np.pi, 100)
            x_cerchio = chuck.radius * np.cos(theta)
            y_cerchio = chuck.radius * np.sin(theta)
            fig.add_trace(
                go.Scatter(
                    x=x_cerchio,
                    y=y_cerchio,
                    mode='lines',
                    fill='toself',
                    name='Chuck'
                )
            )
        else:
            if isinstance(chuck, Square):
                half = chuck.side / 2
                x_quad = [-half, half, half, -half, -half]
                y_quad = [-half, -half, half, half, -half]
                fig.add_trace(
                    go.Scatter(
                        x=x_quad,
                        y=y_quad,
                        mode='lines',
                        fill='toself',
                        name='Chuck'
                    )
                )
            if isinstance(chuck,Rectangle):
                half_base =  chuck.base/ 2
                half_height = chuck.height/2
                x_quad = [-half_base, half_base, half_base, -half_base, -half_base]
                y_quad = [-half_height, -half_height, half_height, half_height, -half_height]
                fig.add_trace(
                    go.Scatter(
                        x=x_quad,
                        y=y_quad,
                        mode='lines',
                        fill='toself',
                        name='Chuck'
                    )
                )
    # Aggiungi i centri dei quadratini
        for i, (x1, y1) in enumerate(posizione_centro):
            fig.add_trace(
                go.Scatter(
                    x=[x1],
                    y=[y1],
                    mode='markers',
                    marker=dict(size=10, color='red'),
                    name=f'Quadratino {i+1} centro'
                )
            )
            # Disegna anche il quadratino attorno al centro
            # half = lato_quadrato / 2
            # x_quad = [x - half, x + half, x + half, x - half, x - half]
            # y_quad = [y - half, y - half, y + half, y + half, y - half]
            # fig.add_trace(
            #     go.Scatter(
            #         x=x_quad,
            #         y=y_quad,
            #         mode='lines',
            #         line=dict(color='blue'),
            #         showlegend=False
            #     )
            # )
        fig.update_layout(
            title='Posizione degli items nel piatto',
        #    xaxis=dict(scaleanchor='y', range=[-6, 6]),
        #    yaxis=dict(range=[-6, 6]),
            width=800,
            height=800
        )
        figure_json = fig.to_plotly_json()
        figure_json['config'] = {'staticPlot': True}
        finalist.append(
            PlotlyFigure(
                label='Chuck vision',
                figure=figure_json,
                index=0,
            )
        )

class ItemPlacement(PlotSection, EntryData):

    m_def=Section(
        description="""
        Section used to describe, if needed, item placement on chucks. The reference frame
        is centered on the chuck center so displacemnt of center of items is given with
        respect the chuck center. If no chuck is provided you can describe the chamber
        shape.
        """
    )

    item_center_x = Quantity(
        type=np.float64,
        a_eln={
            'component':'NumberEditQuantity',
            'defaultDisplayUnit': 'cm'
        },
        unit='cm'
    )

    item_center_y = Quantity(
        type=np.float64,
        a_eln={
            'component':'NumberEditQuantity',
            'defaultDisplayUnit': 'cm'
        },
        unit='cm'
    )

    chamber_geometry=SubSection(
        section_def=Contour,
        repeats=False,
    )

    chuck_geometry=SubSection(
        section_def=Contour,
        repeats=False,
    )

    item_geometry = SubSection(
        section_def = Contour,
        repeats=False,
    )

    def normalize(self, archive, logger):
        super(ItemPlacement, self).normalize(archive, logger)
        if hasattr(self, 'figures') and self.figures:
            self.figures.clear()
        if isinstance(self.chuck_geometry[0], Contour):
            pass
        else:
            make_geometric_represent(self.chuck_geometry[0], self.item_center_x, self.item_center_y, self.figures)




class Item(Entity, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'hide': ['lab_id', 'name'],
            'properties': {
                'order': [
                    'id_wafer_parent',
                    'datetime',
                    'itemShapeType',
                    'id',
                    'isAssembly',
                    'ids_components',
                ],
            },
        }
    )
    id_wafer_parent = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    datetime = Quantity(a_eln={'label': 'date of creation'})
    itemShapeType = Quantity(
        type=MEnum(
            [
                'Wafer with flat standard',
                'Wafer with flat JEIDA',
                'Rectangle shape',
                '1/2 wafer',
                '1/4 wafer',
                'Fragment',
                'Square shape',
                'Powder',
                'Wafer with Notch standard',
            ]
        ),
        a_eln={'component': 'EnumEditQuantity'},
    )
    id = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    isAssembly = Quantity(
        type=bool,
        a_eln={'component': 'BoolEditQuantity'},
    )
    ids_components = Quantity(
        type=str,
        shape=['*'],
        a_eln={'component': 'StringEditQuantity'},
    )
    properties = SubSection(
        section_def=ItemPropertyDefinition,
        repeats=True,
    )


m_package.__init_metainfo__()
